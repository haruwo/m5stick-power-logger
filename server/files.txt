version: '3.8'

services:
  # PostgreSQL Database
  postgres:
    image: postgres:15-alpine
    container_name: m5stick_postgres
    environment:
      POSTGRES_DB: power_logger
      POSTGRES_USER: power_user
      POSTGRES_PASSWORD: power_secure_2025
      TZ: Asia/Tokyo
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    ports:
      - "5432:5432"
    networks:
      - power_logger_net
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U power_user -d power_logger"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis Cache
  redis:
    image: redis:7-alpine
    container_name: m5stick_redis
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    networks:
      - power_logger_net
    restart: unless-stopped
    command: redis-server --appendonly yes --requirepass redis_secure_2025

  # Backend API
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: m5stick_backend
    environment:
      NODE_ENV: production
      DATABASE_URL: postgresql://power_user:power_secure_2025@postgres:5432/power_logger
      REDIS_URL: redis://:redis_secure_2025@redis:6379
      JWT_SECRET: your_jwt_secret_key_here_2025
      PORT: 3000
      TZ: Asia/Tokyo
    volumes:
      - ./backend:/app
      - /app/node_modules
    ports:
      - "3000:3000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started
    networks:
      - power_logger_net
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Frontend Dashboard
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: m5stick_frontend
    environment:
      REACT_APP_API_BASE_URL: http://localhost:8080/api
      REACT_APP_ENVIRONMENT: production
    volumes:
      - ./frontend:/app
      - /app/node_modules
    ports:
      - "3001:3000"
    depends_on:
      - backend
    networks:
      - power_logger_net
    restart: unless-stopped

  # Nginx Reverse Proxy
  nginx:
    image: nginx:alpine
    container_name: m5stick_nginx
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf:ro
      - nginx_logs:/var/log/nginx
    ports:
      - "8080:80"
      - "8443:443"
    depends_on:
      - backend
      - frontend
    networks:
      - power_logger_net
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  nginx_logs:
    driver: local

networks:
  power_logger_net:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

---
# .env file template
DATABASE_URL=postgresql://power_user:power_secure_2025@localhost:5432/power_logger
REDIS_URL=redis://:redis_secure_2025@localhost:6379
JWT_SECRET=your_jwt_secret_key_here_2025
NODE_ENV=production
REACT_APP_API_BASE_URL=http://localhost:8080/api

---
# database/init.sql
-- Power Logger Database Schema
-- Time-series optimized for M5StickC Plus2 data

-- Enable extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_stat_statements";

-- Devices table
CREATE TABLE devices (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    device_id VARCHAR(100) UNIQUE NOT NULL,
    name VARCHAR(255),
    description TEXT,
    location VARCHAR(255),
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Power events table (main time-series data)
CREATE TABLE power_events (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    device_id VARCHAR(100) NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    uptime_ms BIGINT,
    event_type VARCHAR(50) NOT NULL,
    message TEXT,
    battery_percentage INTEGER,
    battery_voltage DECIMAL(5,3),
    wifi_signal_strength INTEGER,
    free_heap BIGINT,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_power_events_device_id ON power_events(device_id);
CREATE INDEX idx_power_events_timestamp ON power_events(timestamp DESC);
CREATE INDEX idx_power_events_event_type ON power_events(event_type);
CREATE INDEX idx_power_events_device_timestamp ON power_events(device_id, timestamp DESC);
CREATE INDEX idx_power_events_metadata_gin ON power_events USING GIN(metadata);

-- Power sessions table (for gantt chart display)
CREATE TABLE power_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    device_id VARCHAR(100) NOT NULL,
    session_start TIMESTAMP WITH TIME ZONE NOT NULL,
    session_end TIMESTAMP WITH TIME ZONE,
    duration_minutes INTEGER,
    start_battery_percentage INTEGER,
    end_battery_percentage INTEGER,
    total_events INTEGER DEFAULT 0,
    session_type VARCHAR(50) DEFAULT 'power_cycle',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_power_sessions_device_id ON power_sessions(device_id);
CREATE INDEX idx_power_sessions_start ON power_sessions(session_start DESC);
CREATE INDEX idx_power_sessions_end ON power_sessions(session_end DESC);

-- Statistics and analytics views
CREATE VIEW device_stats AS
SELECT 
    device_id,
    COUNT(*) as total_events,
    COUNT(DISTINCT DATE(timestamp)) as active_days,
    MIN(timestamp) as first_event,
    MAX(timestamp) as last_event,
    AVG(battery_percentage) as avg_battery,
    AVG(wifi_signal_strength) as avg_wifi_signal
FROM power_events 
GROUP BY device_id;

CREATE VIEW daily_event_summary AS
SELECT 
    device_id,
    DATE(timestamp) as event_date,
    COUNT(*) as event_count,
    COUNT(CASE WHEN event_type = 'power_on' THEN 1 END) as power_on_count,
    COUNT(CASE WHEN event_type = 'power_off' THEN 1 END) as power_off_count,
    AVG(battery_percentage) as avg_battery,
    MIN(battery_percentage) as min_battery,
    MAX(battery_percentage) as max_battery
FROM power_events 
GROUP BY device_id, DATE(timestamp)
ORDER BY device_id, event_date DESC;

-- Trigger to automatically create/update power sessions
CREATE OR REPLACE FUNCTION update_power_sessions()
RETURNS TRIGGER AS $$
BEGIN
    -- Handle power_on events
    IF NEW.event_type = 'power_on' THEN
        -- End any open session for this device
        UPDATE power_sessions 
        SET session_end = NEW.timestamp,
            duration_minutes = EXTRACT(EPOCH FROM (NEW.timestamp - session_start))/60,
            end_battery_percentage = NEW.battery_percentage,
            updated_at = NOW()
        WHERE device_id = NEW.device_id 
        AND session_end IS NULL;
        
        -- Start new session
        INSERT INTO power_sessions (
            device_id, session_start, start_battery_percentage, session_type
        ) VALUES (
            NEW.device_id, NEW.timestamp, NEW.battery_percentage, 'power_cycle'
        );
    END IF;
    
    -- Handle power_off events
    IF NEW.event_type = 'power_off' THEN
        UPDATE power_sessions 
        SET session_end = NEW.timestamp,
            duration_minutes = EXTRACT(EPOCH FROM (NEW.timestamp - session_start))/60,
            end_battery_percentage = NEW.battery_percentage,
            updated_at = NOW()
        WHERE device_id = NEW.device_id 
        AND session_end IS NULL;
    END IF;
    
    -- Update event count for current session
    UPDATE power_sessions 
    SET total_events = total_events + 1,
        updated_at = NOW()
    WHERE device_id = NEW.device_id 
    AND session_start <= NEW.timestamp 
    AND (session_end IS NULL OR session_end >= NEW.timestamp);
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_power_sessions
    AFTER INSERT ON power_events
    FOR EACH ROW
    EXECUTE FUNCTION update_power_sessions();

-- Sample data for testing
INSERT INTO devices (device_id, name, description, location) VALUES
('M5S2_12345678', 'Office Device 1', 'Main office power monitoring', 'Tokyo Office'),
('M5S2_87654321', 'Office Device 2', 'Server room monitoring', 'Tokyo Server Room');

-- Insert sample events
INSERT INTO power_events (device_id, timestamp, event_type, message, battery_percentage, battery_voltage, wifi_signal_strength, free_heap) VALUES
('M5S2_12345678', NOW() - INTERVAL '2 hours', 'power_on', 'External power connected', 85, 4.12, -45, 245760),
('M5S2_12345678', NOW() - INTERVAL '1 hour', 'power_off', 'External power disconnected', 83, 4.08, -47, 243520),
('M5S2_12345678', NOW() - INTERVAL '30 minutes', 'power_on', 'External power connected', 82, 4.05, -44, 244890);

---
# backend/Dockerfile
FROM node:18-alpine

WORKDIR /app

# Install dependencies first (for better caching)
COPY package*.json ./
RUN npm ci --only=production

# Copy application code
COPY . .

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# Change ownership
RUN chown -R nextjs:nodejs /app
USER nextjs

EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

CMD ["npm", "start"]

---
# backend/package.json
{
  "name": "m5stick-power-logger-backend",
  "version": "1.0.0",
  "description": "Backend API for M5StickC Plus2 Power Logger",
  "main": "src/server.js",
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js",
    "test": "jest",
    "lint": "eslint src/",
    "migrate": "node src/migrations/run.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.0.0",
    "compression": "^1.7.4",
    "express-rate-limit": "^6.10.0",
    "express-validator": "^7.0.1",
    "pg": "^8.11.0",
    "redis": "^4.6.7",
    "jsonwebtoken": "^9.0.2",
    "bcryptjs": "^2.4.3",
    "winston": "^3.10.0",
    "winston-daily-rotate-file": "^4.7.1",
    "moment-timezone": "^0.5.43",
    "node-cron": "^3.0.2",
    "dotenv": "^16.0.3"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.6.2",
    "supertest": "^6.3.3",
    "eslint": "^8.45.0"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}

---
# backend/src/server.js
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

const logger = require('./utils/logger');
const db = require('./config/database');
const redis = require('./config/redis');
const routes = require('./routes');
const errorHandler = require('./middleware/errorHandler');

const app = express();
const PORT = process.env.PORT || 3000;

// Security middleware
app.use(helmet());
app.use(compression());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 1000, // limit each IP to 1000 requests per windowMs
  message: 'Too many requests from this IP'
});
app.use('/api/', limiter);

// CORS configuration
app.use(cors({
  origin: process.env.CORS_ORIGIN || '*',
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Device-ID']
}));

// Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Request logging
app.use((req, res, next) => {
  logger.info(`${req.method} ${req.url}`, {
    ip: req.ip,
    userAgent: req.get('User-Agent'),
    deviceId: req.get('X-Device-ID')
  });
  next();
});

// Health check
app.get('/health', async (req, res) => {
  try {
    await db.query('SELECT 1');
    await redis.ping();
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      database: 'connected',
      redis: 'connected'
    });
  } catch (error) {
    logger.error('Health check failed:', error);
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error.message
    });
  }
});

// API routes
app.use('/api', routes);

// Error handling
app.use(errorHandler);

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({
    error: 'Endpoint not found',
    path: req.originalUrl
  });
});

// Start server
const server = app.listen(PORT, '0.0.0.0', () => {
  logger.info(`M5StickC Power Logger Backend running on port ${PORT}`);
  logger.info(`Environment: ${process.env.NODE_ENV}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  logger.info('SIGTERM received, shutting down gracefully');
  server.close(() => {
    db.end();
    redis.quit();
    process.exit(0);
  });
});

module.exports = app;

---
# backend/src/routes/index.js
const express = require('express');
const { body, query, validationResult } = require('express-validator');
const db = require('../config/database');
const redis = require('../config/redis');
const logger = require('../utils/logger');

const router = express.Router();

// Validation middleware
const validateRequest = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      error: 'Validation failed',
      details: errors.array()
    });
  }
  next();
};

// Power events endpoint (M5StickC sends data here)
router.post('/power-events', [
  body('device_id').isString().isLength({ min: 1, max: 100 }),
  body('timestamp').isISO8601(),
  body('event_type').isIn(['power_on', 'power_off', 'battery_low', 'system_error']),
  body('message').optional().isString().isLength({ max: 500 }),
  body('battery_percentage').optional().isInt({ min: 0, max: 100 }),
  body('battery_voltage').optional().isFloat({ min: 0, max: 10 }),
  body('wifi_signal_strength').optional().isInt({ min: -100, max: 0 }),
  body('free_heap').optional().isInt({ min: 0 })
], validateRequest, async (req, res) => {
  try {
    const {
      device_id,
      timestamp,
      uptime_ms,
      event_type,
      message,
      battery_percentage,
      battery_voltage,
      wifi_signal_strength,
      free_heap
    } = req.body;

    // Insert device if not exists
    await db.query(`
      INSERT INTO devices (device_id, name, is_active, updated_at)
      VALUES ($1, $1, true, NOW())
      ON CONFLICT (device_id) 
      DO UPDATE SET updated_at = NOW(), is_active = true
    `, [device_id]);

    // Insert power event
    const result = await db.query(`
      INSERT INTO power_events (
        device_id, timestamp, uptime_ms, event_type, message,
        battery_percentage, battery_voltage, wifi_signal_strength, free_heap
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      RETURNING id
    `, [
      device_id, timestamp, uptime_ms, event_type, message,
      battery_percentage, battery_voltage, wifi_signal_strength, free_heap
    ]);

    // Cache latest event for dashboard
    await redis.setex(`latest_event:${device_id}`, 3600, JSON.stringify(req.body));

    logger.info('Power event recorded', {
      eventId: result.rows[0].id,
      deviceId: device_id,
      eventType: event_type
    });

    res.status(201).json({
      success: true,
      event_id: result.rows[0].id,
      message: 'Event recorded successfully'
    });

  } catch (error) {
    logger.error('Error recording power event:', error);
    res.status(500).json({
      error: 'Failed to record event',
      message: error.message
    });
  }
});

// Get devices
router.get('/devices', async (req, res) => {
  try {
    const result = await db.query(`
      SELECT d.*, ds.* 
      FROM devices d
      LEFT JOIN device_stats ds ON d.device_id = ds.device_id
      WHERE d.is_active = true
      ORDER BY d.updated_at DESC
    `);

    res.json({
      devices: result.rows,
      count: result.rows.length
    });
  } catch (error) {
    logger.error('Error fetching devices:', error);
    res.status(500).json({ error: 'Failed to fetch devices' });
  }
});

// Get power events with pagination and filtering
router.get('/power-events', [
  query('device_id').optional().isString(),
  query('event_type').optional().isIn(['power_on', 'power_off', 'battery_low', 'system_error']),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601(),
  query('page').optional().isInt({ min: 1 }),
  query('limit').optional().isInt({ min: 1, max: 1000 })
], validateRequest, async (req, res) => {
  try {
    const {
      device_id,
      event_type,
      start_date,
      end_date,
      page = 1,
      limit = 100
    } = req.query;

    let whereClause = '1=1';
    const params = [];
    let paramIndex = 1;

    if (device_id) {
      whereClause += ` AND device_id = $${paramIndex++}`;
      params.push(device_id);
    }

    if (event_type) {
      whereClause += ` AND event_type = $${paramIndex++}`;
      params.push(event_type);
    }

    if (start_date) {
      whereClause += ` AND timestamp >= $${paramIndex++}`;
      params.push(start_date);
    }

    if (end_date) {
      whereClause += ` AND timestamp <= $${paramIndex++}`;
      params.push(end_date);
    }

    const offset = (page - 1) * limit;

    const result = await db.query(`
      SELECT * FROM power_events 
      WHERE ${whereClause}
      ORDER BY timestamp DESC
      LIMIT $${paramIndex++} OFFSET $${paramIndex++}
    `, [...params, limit, offset]);

    const countResult = await db.query(`
      SELECT COUNT(*) FROM power_events WHERE ${whereClause}
    `, params);

    res.json({
      events: result.rows,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: parseInt(countResult.rows[0].count),
        pages: Math.ceil(countResult.rows[0].count / limit)
      }
    });

  } catch (error) {
    logger.error('Error fetching power events:', error);
    res.status(500).json({ error: 'Failed to fetch events' });
  }
});

// Get power sessions for Gantt chart
router.get('/power-sessions', [
  query('device_id').optional().isString(),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601()
], validateRequest, async (req, res) => {
  try {
    const { device_id, start_date, end_date } = req.query;

    let whereClause = '1=1';
    const params = [];
    let paramIndex = 1;

    if (device_id) {
      whereClause += ` AND device_id = $${paramIndex++}`;
      params.push(device_id);
    }

    if (start_date) {
      whereClause += ` AND session_start >= $${paramIndex++}`;
      params.push(start_date);
    }

    if (end_date) {
      whereClause += ` AND session_start <= $${paramIndex++}`;
      params.push(end_date);
    }

    const result = await db.query(`
      SELECT 
        id,
        device_id,
        session_start,
        session_end,
        duration_minutes,
        start_battery_percentage,
        end_battery_percentage,
        total_events,
        session_type
      FROM power_sessions 
      WHERE ${whereClause}
      ORDER BY session_start DESC
      LIMIT 1000
    `, params);

    res.json({
      sessions: result.rows,
      count: result.rows.length
    });

  } catch (error) {
    logger.error('Error fetching power sessions:', error);
    res.status(500).json({ error: 'Failed to fetch sessions' });
  }
});

// Get daily event summary for calendar view
router.get('/daily-summary', [
  query('device_id').optional().isString(),
  query('start_date').optional().isISO8601(),
  query('end_date').optional().isISO8601()
], validateRequest, async (req, res) => {
  try {
    const { device_id, start_date, end_date } = req.query;

    let whereClause = '1=1';
    const params = [];
    let paramIndex = 1;

    if (device_id) {
      whereClause += ` AND device_id = $${paramIndex++}`;
      params.push(device_id);
    }

    if (start_date) {
      whereClause += ` AND event_date >= $${paramIndex++}`;
      params.push(start_date);
    }

    if (end_date) {
      whereClause += ` AND event_date <= $${paramIndex++}`;
      params.push(end_date);
    }

    const result = await db.query(`
      SELECT * FROM daily_event_summary 
      WHERE ${whereClause}
      ORDER BY event_date DESC
      LIMIT 365
    `, params);

    res.json({
      daily_summary: result.rows,
      count: result.rows.length
    });

  } catch (error) {
    logger.error('Error fetching daily summary:', error);
    res.status(500).json({ error: 'Failed to fetch daily summary' });
  }
});

// Dashboard stats endpoint
router.get('/dashboard/stats', async (req, res) => {
  try {
    const cacheKey = 'dashboard:stats';
    const cached = await redis.get(cacheKey);
    
    if (cached) {
      return res.json(JSON.parse(cached));
    }

    const [devicesResult, eventsResult, sessionsResult] = await Promise.all([
      db.query('SELECT COUNT(*) as total_devices FROM devices WHERE is_active = true'),
      db.query('SELECT COUNT(*) as total_events FROM power_events WHERE timestamp >= NOW() - INTERVAL \'24 hours\''),
      db.query('SELECT COUNT(*) as active_sessions FROM power_sessions WHERE session_end IS NULL')
    ]);

    const stats = {
      total_devices: parseInt(devicesResult.rows[0].total_devices),
      events_24h: parseInt(eventsResult.rows[0].total_events),
      active_sessions: parseInt(sessionsResult.rows[0].active_sessions),
      timestamp: new Date().toISOString()
    };

    await redis.setex(cacheKey, 300, JSON.stringify(stats)); // Cache for 5 minutes

    res.json(stats);

  } catch (error) {
    logger.error('Error fetching dashboard stats:', error);
    res.status(500).json({ error: 'Failed to fetch dashboard stats' });
  }
});

module.exports = router;

---
# nginx/default.conf
upstream backend {
    server backend:3000;
}

upstream frontend {
    server frontend:3000;
}

server {
    listen 80;
    server_name localhost;
    client_max_body_size 10M;

    # Security headers
    add_header X-Frame-Options DENY always;
    add_header X-Content-Type-Options nosniff always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;

    # Health check
    location /health {
        proxy_pass http://backend/health;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # API routes
    location /api/ {
        proxy_pass http://backend/api/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Device-ID $http_x_device_id;
        
        # Timeout settings
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # CORS headers for API
        add_header Access-Control-Allow-Origin * always;
        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
        add_header Access-Control-Allow-Headers "DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization,X-Device-ID" always;
        
        if ($request_method = 'OPTIONS') {
            add_header Access-Control-Allow-Origin * always;
            add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
            add_header Access-Control-Allow-Headers "DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization,X-Device-ID" always;
            add_header Access-Control-Max-Age 1728000;
            add_header Content-Type 'text/plain; charset=utf-8';
            add_header Content-Length 0;
            return 204;
        }
    }

    # Frontend routes
    location / {
        proxy_pass http://frontend/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Handle React Router
        try_files $uri $uri/ @fallback;
    }
    
    location @fallback {
        proxy_pass http://frontend/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Static files caching
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        proxy_pass http://frontend;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # Logs
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;
}

---
# README.md
# M5StickC Plus2 Power Logger Backend

プロフェッショナルなIoTデータ管理システム - M5StickC Plus2からの電源イベントデータを受信、永続化、可視化

## システム構成

### アーキテクチャ概要
```
M5StickC Plus2 → Nginx → Backend API → PostgreSQL
                    ↓
               Frontend Dashboard
                    ↓
                Redis Cache
```

### サービス構成
- **PostgreSQL**: 時系列データの永続化、JSONB対応
- **Redis**: キャッシュレイヤー、セッション管理
- **Backend API**: Node.js/Express RESTful API
- **Frontend**: React SPA (カレンダー・ガントチャート表示)
- **Nginx**: リバースプロキシ、ロードバランサー

## クイックスタート

### 前提条件
- Docker & Docker Compose
- Git
- 16GB以上のディスク容量

### デプロイ手順

1. **プロジェクトクローン**
```bash
git clone <repository-url>
cd m5stick-power-logger-backend
```

2. **環境設定**
```bash
cp .env.example .env
# .envファイルを編集して環境に合わせて設定
```

3. **起動**
```bash
# バックグラウンドで全サービス起動
docker-compose up -d

# ログ確認
docker-compose logs -f
```

4. **動作確認**
```bash
# ヘルスチェック
curl http://localhost:8080/health

# ダッシュボードアクセス
open http://localhost:8080
```

## API エンドポイント

### データ送信 (M5StickC用)
```http
POST /api/power-events
Content-Type: application/json
X-Device-ID: M5S2_12345678

{
  "device_id": "M5S2_12345678",
  "timestamp": "2025-06-13T12:34:56Z",
  "uptime_ms": 123456,
  "event_type": "power_on",
  "message": "External power connected",
  "battery_percentage": 85,
  "battery_voltage": 4.12,
  "wifi_signal_strength": -45,
  "free_heap": 245760
}
```

### データ取得 (フロントエンド用)
```http
# イベント一覧
GET /api/power-events?device_id=M5S2_12345678&start_date=2025-06-01

# 電源セッション (ガントチャート用)
GET /api/power-sessions?device_id=M5S2_12345678

# 日次サマリー (カレンダー用)
GET /api/daily-summary?start_date=2025-06-01&end_date=2025-06-30

# デバイス一覧
GET /api/devices

# ダッシュボード統計
GET /api/dashboard/stats
```

## データベーススキーマ

### 主要テーブル

**power_events** (時系列データ)
- イベントの詳細記録
- インデックス最適化済み
- JSONB対応メタデータ

**power_sessions** (セッション管理)
- 電源ON/OFF期間の管理
- ガントチャート表示用
- 自動トリガー更新

**devices** (デバイス管理)
- デバイス登録・管理
- 統計情報付きビュー

### パフォーマンス最適化
- 複合インデックス
- パーティショニング対応設計
- 統計ビューによる高速集計

## フロントエンド機能

### カレンダー表示
- 日別イベント数表示
- 色分けによる状態識別
- ドリルダウンナビゲーション

### ガントチャート
- 電源セッション期間表示
- デバイス別タイムライン
- インタラクティブなズーム

### リアルタイムダッシュボード
- デバイス状態監視
- アラート表示
- 統計サマリー

## 運用・監視

### ログ管理
```bash
# アプリケーションログ
docker-compose logs backend

# データベースログ
docker-compose logs postgres

# Nginxアクセスログ
docker-compose logs nginx
```

### バックアップ
```bash
# データベースバックアップ
docker-compose exec postgres pg_dump -U power_user power_logger > backup.sql

# データボリューム確認
docker volume ls | grep m5stick
```

### スケーリング
```bash
# バックエンドサービススケール
docker-compose up -d --scale backend=3

# リソース使用量確認
docker stats
```

## セキュリティ

### 実装済み対策
- Helmet.js による HTTP セキュリティ
- CORS 制御
- レート制限
- 入力値検証
- SQL インジェクション対策

### 本番環境推奨設定
- HTTPS証明書設定
- ファイアウォール設定
- 定期的なセキュリティ更新
- 監査ログの有効化

## カスタマイズ

### 環境変数
```env
DATABASE_URL=postgresql://user:pass@host:port/db
REDIS_URL=redis://:pass@host:port
JWT_SECRET=your_secret_key
NODE_ENV=production
CORS_ORIGIN=https://yourdomain.com
```

### データ保持期間設定
```sql
-- 古いデータの自動削除設定
CREATE OR REPLACE FUNCTION cleanup_old_events()
RETURNS void AS $$
BEGIN
    DELETE FROM power_events 
    WHERE created_at < NOW() - INTERVAL '1 year';
END;
$$ LANGUAGE plpgsql;
```

## トラブルシューティング

### よくある問題

**コンテナが起動しない**
```bash
docker-compose logs <service_name>
docker system prune -f
```

**データベース接続エラー**
```bash
docker-compose exec postgres pg_isready -U power_user
```

**メモリ不足**
```bash
# リソース制限追加
echo "services:
  postgres:
    mem_limit: 1g" >> docker-compose.override.yml
```

## パフォーマンス

### 想定負荷
- 100デバイス同時接続
- 1分間に1000イベント処理
- 1年間のデータ保持

### 最適化項目
- PostgreSQL設定チューニング
- Redis メモリ最適化
- Nginx キャッシュ設定
- アプリケーション接続プール

## ライセンス

MIT License

## サポート

本番環境での使用や技術サポートについては、開発チームまでお問い合わせください。
